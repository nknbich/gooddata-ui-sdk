// (C) 2024 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Bulk CSV analysis request.
 * @export
 * @interface AnalyzeCsvRequest
 */
export interface AnalyzeCsvRequest {
    /**
     * List of individual CSV analysis requests.
     * @type {Array<AnalyzeCsvRequestItem>}
     * @memberof AnalyzeCsvRequest
     */
    analyzeRequests: Array<AnalyzeCsvRequestItem>;
}
/**
 * CSV analysis request.
 * @export
 * @interface AnalyzeCsvRequestItem
 */
export interface AnalyzeCsvRequestItem {
    /**
     * Location of the CSV file to analyze.
     * @type {string}
     * @memberof AnalyzeCsvRequestItem
     */
    location: string;
    /**
     *
     * @type {AnalyzeCsvRequestItemConfig}
     * @memberof AnalyzeCsvRequestItem
     */
    config?: AnalyzeCsvRequestItemConfig;
}
/**
 * CSV analysis request config.
 * @export
 * @interface AnalyzeCsvRequestItemConfig
 */
export interface AnalyzeCsvRequestItemConfig {
    /**
     * Number of rows to return in the flight that represents analysis result. If 0, no rows are returned, if less than 0, all rows that were in the sample are returned.
     * @type {number}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    resultRows?: number;
    /**
     * Maximum number of rows to work with during header detection.
     * @type {number}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    headerDetectMaxRows?: number;
    /**
     * Possible column delimiters.
     * @type {Array<string>}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    delimiters?: Array<string>;
}
/**
 * Describes the results of a CSV analysis of a single file.
 * @export
 * @interface AnalyzeCsvResponse
 */
export interface AnalyzeCsvResponse {
    /**
     * Location of the analyzed file in the source data source.
     * @type {string}
     * @memberof AnalyzeCsvResponse
     */
    location: string;
    /**
     * List of column metadata.
     * @type {Array<AnalyzeCsvResponseColumn>}
     * @memberof AnalyzeCsvResponse
     */
    columns: Array<AnalyzeCsvResponseColumn>;
    /**
     * Preview of the first N rows of the file.
     * @type {Array<Array<object>>}
     * @memberof AnalyzeCsvResponse
     */
    previewData: Array<Array<object>>;
    /**
     *
     * @type {AnalyzeCsvResponseConfig}
     * @memberof AnalyzeCsvResponse
     */
    config?: AnalyzeCsvResponseConfig;
}
/**
 * Describes the result column.
 * @export
 * @interface AnalyzeCsvResponseColumn
 */
export interface AnalyzeCsvResponseColumn {
    /**
     * Name of the column as specified in the file (or autogenerated one if the file has no header).
     * @type {string}
     * @memberof AnalyzeCsvResponseColumn
     */
    name: string;
    /**
     * Type of the column (e.g. string, bool, etc.).
     * @type {string}
     * @memberof AnalyzeCsvResponseColumn
     */
    type: string;
    /**
     * List of date formats that can be used to parse this column as date. Null if there are none.
     * @type {Array<string>}
     * @memberof AnalyzeCsvResponseColumn
     */
    detectedDateFormats?: Array<string>;
}
/**
 * Config used to process the CSV file.
 * @export
 * @interface AnalyzeCsvResponseConfig
 */
export interface AnalyzeCsvResponseConfig {
    /**
     *
     * @type {CsvReadOptions}
     * @memberof AnalyzeCsvResponseConfig
     */
    readOptions?: CsvReadOptions;
    /**
     *
     * @type {CsvParseOptions}
     * @memberof AnalyzeCsvResponseConfig
     */
    parseOptions?: CsvParseOptions;
    /**
     *
     * @type {CsvConvertOptions}
     * @memberof AnalyzeCsvResponseConfig
     */
    convertOptions?: CsvConvertOptions;
}
/**
 * Information about a period in time and how much cached data was removed.
 * @export
 * @interface CacheRemovalInterval
 */
export interface CacheRemovalInterval {
    /**
     * Start timestamp of the removal interval.
     * @type {string}
     * @memberof CacheRemovalInterval
     */
    from: string;
    /**
     * End timestamp of the removal interval.
     * @type {string}
     * @memberof CacheRemovalInterval
     */
    to: string;
    /**
     * Bytes removed during this interval.
     * @type {number}
     * @memberof CacheRemovalInterval
     */
    removed: number;
}
/**
 * Result of scan of data source physical model.
 * @export
 * @interface CacheUsageData
 */
export interface CacheUsageData {
    /**
     *
     * @type {OrganizationCacheUsage}
     * @memberof CacheUsageData
     */
    organizationCacheUsage: OrganizationCacheUsage;
    /**
     * Map of data about the cache usage of the individual workspaces.
     * @type {{ [key: string]: WorkspaceCacheUsage; }}
     * @memberof CacheUsageData
     */
    workspaceCacheUsages: { [key: string]: WorkspaceCacheUsage };
}
/**
 * Options for converting CSV files when reading.
 * @export
 * @interface CsvConvertOptions
 */
export interface CsvConvertOptions {
    /**
     * Whether to check UTF8 validity of string columns.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    checkUtf8?: boolean;
    /**
     * Information about the column types in the table.
     * @type {Array<CsvConvertOptionsColumnType>}
     * @memberof CsvConvertOptions
     */
    columnTypes?: Array<CsvConvertOptionsColumnType>;
    /**
     * Sequence of strings that denote nulls in the data.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    nullValues?: Array<string>;
    /**
     * Sequence of strings that denote true Booleans in the data.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    trueValues?: Array<string>;
    /**
     * Sequence of strings that denote false Booleans in the data.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    falseValues?: Array<string>;
    /**
     * The character used as decimal point in floating-point and decimal data.
     * @type {string}
     * @memberof CsvConvertOptions
     */
    decimalPoint?: string;
    /**
     * Whether string / binary columns can have null values.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    stringsCanBeNull?: boolean;
    /**
     * Whether quoted values can be null.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    quotedStringsCanBeNull?: boolean;
    /**
     * The names of columns to include in the Table. If empty, the Table will include all columns from the CSV file. If not empty, only these columns will be included, in this order.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    includeColumns?: Array<string>;
    /**
     * If false, columns in includeColumns but not in the CSV file will error out.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    includeMissingColumns?: boolean;
    /**
     * Whether to try to automatically dict-encode string / binary data.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    autoDictEncode?: boolean;
    /**
     * The maximum dictionary cardinality for autoDictEncode.
     * @type {number}
     * @memberof CsvConvertOptions
     */
    autoDictMaxCardinality?: number;
    /**
     * Sequence of strptime()-compatible format strings, tried in order when attempting to infer or convert timestamp values.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    timestampParsers?: Array<string>;
}
/**
 * Information about a certain column in the table.
 * @export
 * @interface CsvConvertOptionsColumnType
 */
export interface CsvConvertOptionsColumnType {
    /**
     * The column name.
     * @type {string}
     * @memberof CsvConvertOptionsColumnType
     */
    name?: string;
    /**
     * The column type.
     * @type {string}
     * @memberof CsvConvertOptionsColumnType
     */
    type?: string;
    /**
     * Whether the data in the given column can be null.
     * @type {boolean}
     * @memberof CsvConvertOptionsColumnType
     */
    nullable?: boolean;
}
/**
 * Options for parsing CSV files.
 * @export
 * @interface CsvParseOptions
 */
export interface CsvParseOptions {
    /**
     * The character delimiting individual cells in the CSV data.
     * @type {string}
     * @memberof CsvParseOptions
     */
    delimiter?: string;
    /**
     * The character used optionally for quoting CSV values or false to disable quoting.
     * @type {object}
     * @memberof CsvParseOptions
     */
    quoteChar?: object;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     * @type {boolean}
     * @memberof CsvParseOptions
     */
    doubleQuote?: boolean;
    /**
     * The character used optionally for escaping special characters or false to disable escaping.
     * @type {object}
     * @memberof CsvParseOptions
     */
    escapeChar?: object;
    /**
     * Whether newline characters are allowed in CSV values.
     * @type {boolean}
     * @memberof CsvParseOptions
     */
    newlinesInValues?: boolean;
    /**
     * Whether empty lines are ignored in CSV input.
     * @type {boolean}
     * @memberof CsvParseOptions
     */
    ignoreEmptyLines?: boolean;
}
/**
 * Options for reading CSV files.
 * @export
 * @interface CsvReadOptions
 */
export interface CsvReadOptions {
    /**
     * Whether to use multiple threads to accelerate reading.
     * @type {boolean}
     * @memberof CsvReadOptions
     */
    useThreads?: boolean;
    /**
     * How many bytes to process at a time from the input stream.
     * @type {number}
     * @memberof CsvReadOptions
     */
    blockSize?: number;
    /**
     * The number of rows to skip before the column names (if any) and the CSV data.
     * @type {number}
     * @memberof CsvReadOptions
     */
    skipRows?: number;
    /**
     * The number of rows to skip after the column names.
     * @type {number}
     * @memberof CsvReadOptions
     */
    skipRowsAfterNames?: number;
    /**
     * The column names of the target table.
     * @type {Array<string>}
     * @memberof CsvReadOptions
     */
    columnNames?: Array<string>;
    /**
     * Whether to autogenerate column names if columnNames is empty.
     * @type {boolean}
     * @memberof CsvReadOptions
     */
    autoGenerateColumnNames?: boolean;
    /**
     * The character encoding of the CSV data.
     * @type {string}
     * @memberof CsvReadOptions
     */
    encoding?: string;
}
/**
 * Request containing the information necessary to import one or more CSV files from the staging area.
 * @export
 * @interface ImportCsvRequest
 */
export interface ImportCsvRequest {
    /**
     * Information about the individual tables.
     * @type {Array<ImportCsvRequestTable>}
     * @memberof ImportCsvRequest
     */
    tables: Array<ImportCsvRequestTable>;
}
/**
 * Information about a particular table.
 * @export
 * @interface ImportCsvRequestTable
 */
export interface ImportCsvRequestTable {
    /**
     * Name of the table.
     * @type {string}
     * @memberof ImportCsvRequestTable
     */
    name: string;
    /**
     *
     * @type {ImportCsvRequestTableSource}
     * @memberof ImportCsvRequestTable
     */
    source: ImportCsvRequestTableSource;
}
/**
 * Information about source data for a particular table.
 * @export
 * @interface ImportCsvRequestTableSource
 */
export interface ImportCsvRequestTableSource {
    /**
     * Location of the data in the staging area.
     * @type {string}
     * @memberof ImportCsvRequestTableSource
     */
    location: string;
    /**
     *
     * @type {ImportCsvRequestTableSourceConfig}
     * @memberof ImportCsvRequestTableSource
     */
    config: ImportCsvRequestTableSourceConfig;
}
/**
 * Config to use when accessing the data for executions, etc.
 * @export
 * @interface ImportCsvRequestTableSourceConfig
 */
export interface ImportCsvRequestTableSourceConfig {
    /**
     *
     * @type {CsvReadOptions}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    readOptions?: CsvReadOptions;
    /**
     *
     * @type {CsvParseOptions}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    parseOptions?: CsvParseOptions;
    /**
     *
     * @type {CsvConvertOptions}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    convertOptions?: CsvConvertOptions;
    /**
     * Date formats to use to use to read the given columns.
     * @type {{ [key: string]: string; }}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    columnDateFormats?: { [key: string]: string };
}
/**
 * Settings for organization cache.
 * @export
 * @interface OrganizationCacheSettings
 */
export interface OrganizationCacheSettings {
    /**
     * Extra cache budget the organization can allocate among its workspaces, in bytes.
     * @type {number}
     * @memberof OrganizationCacheSettings
     */
    extraCacheBudget: number;
}
/**
 * Data about the whole organization\'s cache usage.
 * @export
 * @interface OrganizationCacheUsage
 */
export interface OrganizationCacheUsage {
    /**
     *
     * @type {OrganizationCacheSettings}
     * @memberof OrganizationCacheUsage
     */
    settings: OrganizationCacheSettings;
    /**
     *
     * @type {OrganizationCurrentCacheUsage}
     * @memberof OrganizationCacheUsage
     */
    current: OrganizationCurrentCacheUsage;
    /**
     * List of cache removal intervals.
     * @type {Array<CacheRemovalInterval>}
     * @memberof OrganizationCacheUsage
     */
    removalIntervals: Array<CacheRemovalInterval>;
}
/**
 * Current cache usage of the organization.
 * @export
 * @interface OrganizationCurrentCacheUsage
 */
export interface OrganizationCurrentCacheUsage {
    /**
     * Cache currently used by the organization, in bytes.
     * @type {number}
     * @memberof OrganizationCurrentCacheUsage
     */
    cacheUsed: number;
    /**
     * Start timestamp of removal period.
     * @type {string}
     * @memberof OrganizationCurrentCacheUsage
     */
    removalPeriodStart?: string;
    /**
     * Bytes removed since start due to insufficient cache.
     * @type {number}
     * @memberof OrganizationCurrentCacheUsage
     */
    removedSinceStart: number;
}
/**
 * Information related to uploading a file to the staging area.
 * @export
 * @interface StagingUploadLocation
 */
export interface StagingUploadLocation {
    /**
     * Location relative to the root of the storage.
     * @type {string}
     * @memberof StagingUploadLocation
     */
    location: string;
    /**
     * Pre-signed upload URL to PUT the file to.
     * @type {string}
     * @memberof StagingUploadLocation
     */
    uploadUrl: string;
}
/**
 * Cache settings for the workspace.
 * @export
 * @interface WorkspaceCacheSettings
 */
export interface WorkspaceCacheSettings {
    /**
     * Extra cache for the workspace, in bytes.
     * @type {number}
     * @memberof WorkspaceCacheSettings
     */
    extraCache: number;
}
/**
 * Data about a particular workspace cache usage.
 * @export
 * @interface WorkspaceCacheUsage
 */
export interface WorkspaceCacheUsage {
    /**
     *
     * @type {WorkspaceCacheSettings}
     * @memberof WorkspaceCacheUsage
     */
    settings: WorkspaceCacheSettings;
    /**
     *
     * @type {WorkspaceCurrentCacheUsage}
     * @memberof WorkspaceCacheUsage
     */
    current: WorkspaceCurrentCacheUsage;
    /**
     * List of cache removal intervals for workspace.
     * @type {Array<CacheRemovalInterval>}
     * @memberof WorkspaceCacheUsage
     */
    removalIntervals: Array<CacheRemovalInterval>;
}
/**
 * Current cache usage of the workspace.
 * @export
 * @interface WorkspaceCurrentCacheUsage
 */
export interface WorkspaceCurrentCacheUsage {
    /**
     * Cache used by the workspace.
     * @type {number}
     * @memberof WorkspaceCurrentCacheUsage
     */
    cacheUsed: number;
    /**
     * Cache available for the workspace.
     * @type {number}
     * @memberof WorkspaceCurrentCacheUsage
     */
    cacheAvailable: number;
    /**
     * Start timestamp of removal period for the workspace.
     * @type {string}
     * @memberof WorkspaceCurrentCacheUsage
     */
    removalPeriodStart: string;
    /**
     * Bytes removed since start due to insufficient cache for the workspace.
     * @type {number}
     * @memberof WorkspaceCurrentCacheUsage
     */
    removedSinceStart: number;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv: async (
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("analyzeCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'analyzeCsvRequest' is not null or undefined
            assertParamExists("analyzeCsv", "analyzeCsvRequest", analyzeCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/analyze`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof analyzeCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
                : analyzeCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/collectCacheUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation: async (
            dataSourceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getStagingUploadLocation", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/staging/upload`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("importCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'importCsvRequest' is not null or undefined
            assertParamExists("importCsv", "importCsvRequest", importCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/import`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof importCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
                : importCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeCsv(
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyzeCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeCsv(
                dataSourceId,
                analyzeCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectCacheUsage(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheUsageData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectCacheUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStagingUploadLocation(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StagingUploadLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStagingUploadLocation(
                dataSourceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(
                dataSourceId,
                importCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv(
            requestParameters: ActionsApiAnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<AnalyzeCsvResponse>> {
            return localVarFp
                .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData> {
            return localVarFp.collectCacheUsage(options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {ActionsApiGetStagingUploadLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation(
            requestParameters: ActionsApiGetStagingUploadLocationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<StagingUploadLocation> {
            return localVarFp
                .getStagingUploadLocation(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(
            requestParameters: ActionsApiImportCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    analyzeCsv(
        requestParameters: ActionsApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<AnalyzeCsvResponse>>;

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;

    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {ActionsApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getStagingUploadLocation(
        requestParameters: ActionsApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<StagingUploadLocation>;

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    importCsv(
        requestParameters: ActionsApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for analyzeCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiAnalyzeCsvRequest
 */
export interface ActionsApiAnalyzeCsvRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiAnalyzeCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {AnalyzeCsvRequest}
     * @memberof ActionsApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest;
}

/**
 * Request parameters for getStagingUploadLocation operation in ActionsApi.
 * @export
 * @interface ActionsApiGetStagingUploadLocationRequest
 */
export interface ActionsApiGetStagingUploadLocationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiGetStagingUploadLocation
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for importCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiImportCsvRequest
 */
export interface ActionsApiImportCsvRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiImportCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ImportCsvRequest}
     * @memberof ActionsApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public analyzeCsv(requestParameters: ActionsApiAnalyzeCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .collectCacheUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {ActionsApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getStagingUploadLocation(
        requestParameters: ActionsApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .getStagingUploadLocation(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public importCsv(requestParameters: ActionsApiImportCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * CacheUsageApi - axios parameter creator
 * @export
 */
export const CacheUsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/collectCacheUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * CacheUsageApi - functional programming interface
 * @export
 */
export const CacheUsageApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CacheUsageApiAxiosParamCreator(configuration);
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectCacheUsage(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheUsageData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectCacheUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * CacheUsageApi - factory interface
 * @export
 */
export const CacheUsageApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = CacheUsageApiFp(configuration);
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData> {
            return localVarFp.collectCacheUsage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CacheUsageApi - interface
 * @export
 * @interface CacheUsageApi
 */
export interface CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;
}

/**
 * CacheUsageApi - object-oriented interface
 * @export
 * @class CacheUsageApi
 * @extends {BaseAPI}
 */
export class CacheUsageApi extends BaseAPI implements CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return CacheUsageApiFp(this.configuration)
            .collectCacheUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesAnalysisApi - axios parameter creator
 * @export
 */
export const DataSourceFilesAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv: async (
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("analyzeCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'analyzeCsvRequest' is not null or undefined
            assertParamExists("analyzeCsv", "analyzeCsvRequest", analyzeCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/analyze`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof analyzeCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
                : analyzeCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - functional programming interface
 * @export
 */
export const DataSourceFilesAnalysisApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesAnalysisApiAxiosParamCreator(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeCsv(
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyzeCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeCsv(
                dataSourceId,
                analyzeCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - factory interface
 * @export
 */
export const DataSourceFilesAnalysisApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesAnalysisApiFp(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv(
            requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<AnalyzeCsvResponse>> {
            return localVarFp
                .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - interface
 * @export
 * @interface DataSourceFilesAnalysisApi
 */
export interface DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApiInterface
     */
    analyzeCsv(
        requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<AnalyzeCsvResponse>>;
}

/**
 * Request parameters for analyzeCsv operation in DataSourceFilesAnalysisApi.
 * @export
 * @interface DataSourceFilesAnalysisApiAnalyzeCsvRequest
 */
export interface DataSourceFilesAnalysisApiAnalyzeCsvRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesAnalysisApiAnalyzeCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {AnalyzeCsvRequest}
     * @memberof DataSourceFilesAnalysisApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest;
}

/**
 * DataSourceFilesAnalysisApi - object-oriented interface
 * @export
 * @class DataSourceFilesAnalysisApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesAnalysisApi extends BaseAPI implements DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApi
     */
    public analyzeCsv(
        requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesAnalysisApiFp(this.configuration)
            .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesImportApi - axios parameter creator
 * @export
 */
export const DataSourceFilesImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("importCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'importCsvRequest' is not null or undefined
            assertParamExists("importCsv", "importCsvRequest", importCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/import`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof importCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
                : importCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesImportApi - functional programming interface
 * @export
 */
export const DataSourceFilesImportApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesImportApiAxiosParamCreator(configuration);
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(
                dataSourceId,
                importCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesImportApi - factory interface
 * @export
 */
export const DataSourceFilesImportApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesImportApiFp(configuration);
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(
            requestParameters: DataSourceFilesImportApiImportCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesImportApi - interface
 * @export
 * @interface DataSourceFilesImportApi
 */
export interface DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApiInterface
     */
    importCsv(
        requestParameters: DataSourceFilesImportApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for importCsv operation in DataSourceFilesImportApi.
 * @export
 * @interface DataSourceFilesImportApiImportCsvRequest
 */
export interface DataSourceFilesImportApiImportCsvRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ImportCsvRequest}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest;
}

/**
 * DataSourceFilesImportApi - object-oriented interface
 * @export
 * @class DataSourceFilesImportApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesImportApi extends BaseAPI implements DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApi
     */
    public importCsv(
        requestParameters: DataSourceFilesImportApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesImportApiFp(this.configuration)
            .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceStagingLocationApi - axios parameter creator
 * @export
 */
export const DataSourceStagingLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation: async (
            dataSourceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getStagingUploadLocation", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/staging/upload`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceStagingLocationApi - functional programming interface
 * @export
 */
export const DataSourceStagingLocationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceStagingLocationApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStagingUploadLocation(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StagingUploadLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStagingUploadLocation(
                dataSourceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceStagingLocationApi - factory interface
 * @export
 */
export const DataSourceStagingLocationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceStagingLocationApiFp(configuration);
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {DataSourceStagingLocationApiGetStagingUploadLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation(
            requestParameters: DataSourceStagingLocationApiGetStagingUploadLocationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<StagingUploadLocation> {
            return localVarFp
                .getStagingUploadLocation(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceStagingLocationApi - interface
 * @export
 * @interface DataSourceStagingLocationApi
 */
export interface DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {DataSourceStagingLocationApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApiInterface
     */
    getStagingUploadLocation(
        requestParameters: DataSourceStagingLocationApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<StagingUploadLocation>;
}

/**
 * Request parameters for getStagingUploadLocation operation in DataSourceStagingLocationApi.
 * @export
 * @interface DataSourceStagingLocationApiGetStagingUploadLocationRequest
 */
export interface DataSourceStagingLocationApiGetStagingUploadLocationRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceStagingLocationApiGetStagingUploadLocation
     */
    readonly dataSourceId: string;
}

/**
 * DataSourceStagingLocationApi - object-oriented interface
 * @export
 * @class DataSourceStagingLocationApi
 * @extends {BaseAPI}
 */
export class DataSourceStagingLocationApi extends BaseAPI implements DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {DataSourceStagingLocationApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApi
     */
    public getStagingUploadLocation(
        requestParameters: DataSourceStagingLocationApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceStagingLocationApiFp(this.configuration)
            .getStagingUploadLocation(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
